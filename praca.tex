%Przykładowy plik ułatwiający złożenie projektu dyplomowego inżynierskiego.
%UWAGA: Generowany napis na stronie tytułowej o treści PROJEKT DYPLOMOWY INŻYNIERSKI został zaproponowany przeze mnie i nie jest, póki co, potwierdzony przez władze wydziału. Przed ostatecznym oddaniem tak złożonej pracy należy upewnić się jaka powinna być treść tego napisu. W momencie gdy uzyskam informację na temat treści tego napisu, dokonam niezbędnych zmian w źródłach.

\documentclass[eng,printmode]{mgr}
%opcje klasy dokumentu mgr.cls zostały opisane w dołączonej instrukcji

%poniżej deklaracje użycia pakietów, usunąć to co jest niepotrzebne
%\usepackage{polski} %przydatne podczas składania dokumentów w j. polskim
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} %poprawne składanie polskich czcionek
%pakiety do grafiki
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{psfrag}

%pakiety dodające dużo dodatkowych poleceń matematycznych
\usepackage{amsmath}
\usepackage{amsfonts}

%pakiety wspomagające i poprawiające składanie tabel
\usepackage{supertabular}
\usepackage{array}
\usepackage{tabularx}
\usepackage{hhline}
\usepackage{multirow}
\usepackage{indentfirst}
\usepackage{enumitem}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\usepackage[justification=centering]{caption}
%pakiet wypisujący na marginesie etykiety równań i rysunków zdefiniowanych przez \label{}, chcąc wygenerować finalną wersję dokumentu wystarczy usunąć poniższą linię
%\usepackage{showlabels}


%definicje własnych poleceń
\newcommand{\R}{I\!\!R} %symbol liczb rzeczywistych, działa tylko w trybie matematycznym
\newtheorem{theorem}{Twierdzenie}[section] %nowe otoczenie do składania twierdzeń

%dane do złożenia strony tytułowej
\title{System lokalizacji samolotów z wykorzystaniem ADS-B}
\engtitle{Airplane tracking system using ADS-B}
\author{Karol Szpila}
\supervisor{\vfil dr in\.z. Krzysztof Halawa\\
\\ Katedra Informatyki Technicznej}
%\guardian{dr hab. inż. Imię Nazwisko Prof. PWr, I-6} %nie używać jeśli opiekun jest tą samą osobą co prowadzący pracę

%\date{2008} %standardowo u dołu strony tytułowej umieszczany jest bieżący rok, to polecenie pozwala wstawić dowolny rok

%poniżej jest lista kierunków i specjalności na wydziale elektroniki, należy wybrać właściwe lub dopisać jeśli nie ma odpowiednich
\field{Automatyka i Robotyka (AIR)}
\specialisation{Technologie Informacyjne\\ w Systemach Automatyki (ART)}
%\specialisation{Robotyka (ARR)}
%\specialisation{Komputerowe sieci sterowania (ARK)}
%\specialisation{Systemy informatyczne w automatyce (ASI)}
%\specialisation{Komputerowe systemy zarządzania \\procesami produkcyjnymi (ARS)}
%\field{Elektronika i telekomunikacja (EIT)}
%\specialisation{Akustyka (ETA)}
%\specialisation{Aparatura elektroniczna (EAE)}
%\specialisation{Elektroniczne i komputerowe \\systemy automatyki (ESA)}
%\specialisation{Zastosowania inżynierii komputerowej \\w technice (EZI)}
%\specialisation{Inżynieria dźwięku (EID)}
%\specialisation{Elektronika stosowana \\i optokomunikacja (TEO)}
%\specialisation{Telekomunikacyjne sieci szerokopasmowe (TSS)}
%\specialisation{Teleinformatyczne sieci mobilne (TSM)}
%\specialisation{Sygnały w telekomunikacji cyfrowej (TSC)}
%\specialisation{Teleinformatyczne systemy rozsiewcze (TSR)}
%\field{Informatyka (INF)}
%\specialisation{Systemy informatyki w medycynie \\i technice (IMT)}
%\specialisation{Inżynieria systemów informatycznych (INS)}
%\specialisation{Inżynieria internetowa (INT)}
%\specialisation{Systemy i sieci komputerowe (ISK)}
%\field{Teleinformatyka (TIN)}
%\specialisation{Teleinformatyka (TIN)}

%tutaj zaczyna się właściwa treść dokumentu
\begin{document}
%\bibliographystyle{plabbrv} %tylko gdy używamy BibTeXa, ustawia polski styl bibliografii

\maketitle %polecenie generujące stronę tytułową
%\dedication{6cm}{To jest przykładowa treść opcjonalnej dedykacji, należy ją zmienić lub usunąć w całości polecenie \texttt{$\backslash$dedication}}

\tableofcontents %spis treści

%poniżej znajduje się przykładowa treść dalszej części dokumentu, zainteresowanych zachęcam do rozszyfrowania frazy "Lorem ipsum" :)
\let\cleardoublepage\clearpage %usuwa puste strony pomiaedzy rozdziałami

\chapter{ Wstęp }
ADS-B (ang. Automatic Dependent Surveillance–Broadcast) to system służący do śledzenia statków powietrznych wykorzystywany w kontroli ruchu powietrznego. Powstał, aby uzupełniać pracę PSR (ang. Primary Surveilance Radar) i w przyszłości całkowicie go zastąpić. PSR to radar aktywny bazujący na wysyłaniu fal elektromagnetycznych oraz pomiarze czasu powrotu fali odbitej od przeszkody. Wadą takich systemów jest brak informacji o wykrytym obiekcie poza jego lokalizacją i rozmiarem, wrażliwość na ukształtowanie terenu oraz warunki pogodowe. ADS-B bazuje na lokalizacji przy pomocy satelit GPS. Statki powietrzne w sposób ciągły ustalają swoją pozycję oraz nadają drogą radiową swoje położenie, prędkość oraz identyfikator.
\\


Mode-S to system SSR (ang. Secondary Surveillance Radar) wykorzystywania do odpytywania statku powietrznego o danym 24-bitowym adresie ICAO (ang International Civil Aviation Organization). SSR to wtórny radar dozorowania, uzupełniający prace PSR o dodatkowe informacje odebrane od statku powietrznego. Zapytania wysyłane są przez ATM (ang. Air Traffic Management) na częstotliwości 1030Mhz, natomiast odpowiedzi na 1090Mhz. ADS-B wykorzystuje Mode-S jako technologię do przesyłania informacji.
\begin{table}[ph]
\caption{\textit{ Rodzaje pakietów Mode-S}}
\label{tab:adsb}
  \centering
  \def\arraystretch{1.3}% 
  \begin{tabular}{|c|c|c|}
  \hline
  \multicolumn{1}{|c|}{Rodzaj wiadomości} & \multicolumn{1}{c|}{Downlink Format} & \multicolumn{1}{c|}{Zawartość} \\\cline{1-3}
  \multirow{4}{*}{Mode-S (56 bitów)} 
  				 & \multicolumn{1}{c|}{DF0} & \multicolumn{1}{c|}{Odpowiedz Short Air to Air ACAS} \\\cline{2-3}
                 & \multicolumn{1}{c|}{DF4} & \multicolumn{1}{c|}{Poziom lotu} \\\cline{2-3}
                 & \multicolumn{1}{c|}{DF5} & \multicolumn{1}{c|}{Identyfikator (Roll-call)} \\\cline{2-3}
                 & \multicolumn{1}{c|}{DF11} & \multicolumn{1}{c|}{Odpowiedz All-call} \\\hline
  \multirow{6}{*}{Mode-S (112 bitów)} 
  				 & \multicolumn{1}{c|}{DF16} & \multicolumn{1}{c|}{Odpowiedz Long Air to Air ACAS} \\\cline{2-3}
                 & \multirow{5}{*}{DF17 (ADS-B)} & Pozycja powietrzna \\\hhline{~~~} 
                 &                       & pozycja lądowa \\\hhline{~~~} 
                 &                       & status \\\hhline{~~~} 
                 &                       & ID i rodzaj samolotu  \\\hhline{~~~} 
                 &                       & prędkość powietrzna \\\hline
 \multirow{2}{*}{Mode-S EHS (112 bitów)} 
	& \multicolumn{1}{c|}{DF20} & \multicolumn{1}{c|}{Poziom lotu oraz (BDS 4.0/5.0/6.0)} \\\cline{2-3}
	& \multicolumn{1}{c|}{DF21} & \multicolumn{1}{c|}{ID oraz (BDS 4.0/5.0/6.0)} \\\hline
 \end{tabular}
\end{table}
\newpage

Powyższa tabela prezentuje podział wiadomości Mode-S ze względu na rozmiar bloku danych oraz DF (ang. Downlink Format), czyli format odebranej ramki. Wyróżniamy wiadomości krótkie o długości 56 bitów i rozszerzone 112 bitowe.DF0 i DF16 wykorzystywane są w ACAS (ang. Airborne Collision Avoidance System). ACAS to system zapobiegania kolizji w kontroli ruchu powietrznego. Wyróżniamy odpowiedz Short Air to Air ACAS (DF0), odbierane przez stacje ATM, oraz Long Air to Air ACAS (DF16), stosowaną do informowania poszczególnych statków o możliwości kolizji. Uczestnicy ruchu wysyłający ramkę DF5 potwierdzają, że są wyposarzone w transponder Mode-S. Ponadto, można wyróżnić odpowiedzi Mode-S EHS (ang. Enhanced Surveillance) DF20 i DF21, które zawierają dodatkowe informacja niedostępne w ADS-B, w zależności od wysłanego przez kontrolę naziemną BDS (ang. Comm-B Data Selector). BDS to numer określający żądaną w odpowiedzi informację. Tylko SSR który wysłał zapytanie Mode-S EHS jest wstanie zdekodować otrzymany pakiet DF20 i DF21, ponieważ nie zawiera ona wysłanego BDS. Poniżej przedstawiono tabelę z parametrami odpowiadającymi poszczególnym BDS.
\begin{table}[ph]
\caption{\textit{ BDS dla wiadomości DF20 i DF21}}

  \centering
  \begin{tabular}{l}
  \\
    \includegraphics[width=\textwidth]{images/bds.png}
 \end{tabular}
\end{table}

Wiadomość Mode-S można odbierać przy pomocy dowolnego odbiornika dostrojonego na częstotliwości 1090MHz. Tunery z układem RTL2832U można łatwo przekształcić w SDR (ang. Software Defined Radio) SDR to system komunikacji radiowej w którym parametry odbiornika są konfigurowane poprzez pogram bez ingerencji w sprzęt. Wspomniany odbiornik jest znacznie tańszy od profesjonalnych rozwiązań, co spopularyzowało ADS-B w zastosowaniach amatorskich. 



\chapter{ Cele i założenia projektowe }
Celem niniejszej pracy jest stworzenie prototypu systemu pozwalającego na lokalizację oraz zbieranie informacji o  statkach powietrznych wyposażonych w transpondery ADS-B. W systemie można wyróżnić dwie zasadnicze części.
Wewnętrzną odpowiedzialna za wykrywanie, zbieranie i dekodowanie wiadomości oraz wizualną, zajmującą się prezentacją danych oraz interakcją z użytkownikiem. Urządzenie można wykorzystać jako alternatywa dla drogich i profesjonalny systemów w przypadku zastosowań amatorskich.

\section{Środowisko sprzętowe i wykorzystane narzędzia}
W tym podrozdziale zostaną przedstawiono wykorzystanie w systemie urządzenia oraz środowisko programistyczne.
\\
Jako odbiornik radiowy zostanie wykorzystany tuner DVB-T z układem RTL2832U wyposażony w interfejs USB. Urządzenie można łatwo zamienić w SDR. Zdecydowano się na wykorzystanie mikrokontrolera firmy ST z serii STM32F767, ze względu na posiadanie peryferiów niezbędnych do obsługi urządzeń w systemie, oraz dostępność narzędzi i oprogramowania. W projekcie wykorzystano wyświetlacz LCD-TFT o przekątnej 10.1 cala.
Zdecydowano się na wykorzystanie języków programowania C99 oraz C++ 2014.
Poniżej wymieniono użyte biblioteki.
\begin{itemize}
  \item librtl-sdr - obsługa Tunera DVB-T jako SDR.
  \item STM32 USB Host Library - komunikacja mikrokontrolera z radiem poprzez interfejs USB.
  \item STemWin - obsługa wyświetlacza z panelem dotykowym.
  \item HAL - konfiguracja i interakcja na niskim poziomie z warstwą sprzętową.
\end{itemize}


Zdecydowano się na wykorzystanie systemu operacyjnego FreeRTOS, w celu zapewnienia wielozadaniowości oraz mechanizmów do zarządzania zasobami sprzętowymi. Do programowania urządzenia wykorzystano programatora ST-Link z zestawu uruchomieniowego STM32F429I-DISC1. Poniżej zaprezentowano wykorzystane środowisko programowe.

\begin{itemize}
  \item Atollic True Studio - środowisko do programowania mikrokontrolerów.
  \item STM32CubeMx - generowania kodu konfiguracyjnego dla układów STM32.
  \item Circuit Maker - wykonanie projektu PCB.
\end{itemize}

\chapter{ Architektura sprzętowa}



\section{ Schemat Urządzenia}
W tym rozdziale zostanie opisana część sprzętowa projektu, czyli schemat urządzenia oraz projekt PCB, wykorzystane elementy oraz zewnętrzne urządzenia.
\subsection*{Zasilanie}
Urządzenie jest zasilanie z zewnętrznego źródła 5V poprzez port USB typu mini A. Pozwala to na podłączenie PCB zarówno do sieci przy pomocy ogólnodostępnych przetwornic lub akumulatorów z wyjściem USB.Stabilizator LM1117 wykorzysto bo obniżenia napięcia zasilania do wartości 3,3V przy jakiej pracują ukłądy scalone znajdujące się na PCB.Poniżej przedstawiono schemat podłączania.

\begin{figure}[!h]
    \centering
    \includegraphics[width=\textwidth]{schematics/power.png}
    \caption{\textit{\scriptsize Schemat części zasilania PCB}}
\end{figure}
\subsection*{Mikrokontroler}
Wykorzystany mikrokontroler to STM32F767ZIT6. Układ został wybrany ze względu na zmieszczenie w najmniejszej obudowie wszystkich wymaganych układów peryferiów takich jak: układ LDTC do sprzętowej obsługi wyświetlacza LCD, kontroler zewnętrznej pamięci pozwalający obsłużyć SDRAM i interfejsy komunikacyjne USB, I2C oraz UART. Poniżej przedstawiono schemat podłączenia.

\begin{figure}[!h]
    \centering
    \includegraphics[height=\textwidth, angle=90]{schematics/uC.png}
    \caption{\textit{\scriptsize Schemat podłączenia mikrokontrolera STM32f767ZIT6}}
\end{figure}

\subsection*{Interfejsy komunikacyjne}
System posiada gniazdo na kartę Micro SD, która może zostać wykorzysta do przechowywania skompresowanych obrazów do tła GUI lub map pozwalających lepiej orientować się w terenie na podstawie obrazu z radaru. Do programowania mikrokontrolera wykorzystany został dedykowany interfejs SWD zgodny z ST-Link.USB wykorzystano do komunikacji z SDR (eng Software Defined Radio). Interfejs został wyprowadzony poprzez gniazdo Micro USB-B pozwalając w ten sposób zaoszczędzić miejsca na PCB. System jako Host będzie zasilać podłączony układy którego pobór nie powinien przekroczyć, zgodznie ze standardem USB2.0, 500mA . Z tego powodu zastosowano przełącznik STMPS2141STR. W przypadku podania stanu wysokiego na pin USB PSO układ zostanie włączony. Jeżeli nie występują żadne sytuacje nieporządne takie jak przetężenie prądowe czy zwarcie, zapali się zielona dioda sygnalizująca poprawnie działanie. W przypadku jakichkolwiek problemów prąd zostanie natychmiast odcięty a układ wystawi wysoki stan na pin FAULT informując o tym mikrokontroler i zapalając czerwona diodę. W celu zabezpieczania interfejsu przed niepożądanymi wyładowaniami elektrostatycznymi związanymi z dotykaniem urządzenia czy wkładaniem urządzenia do gniazda zastosowano układ ochrony ESD (ang . Electro Static Discharge ) STMECMF02-4CMX8, który pełni również funkcję filtru EMI, (ang. Electroagnecitc Interferences)dedykowany dla USB2.0. Poniżej przedstawiono schemat połączenia układów.
 %sprawdzic czy prawda z h na faul

\begin{figure}[!h]
    \centering
    \includegraphics[width=\textwidth]{schematics/conn.png}
    \caption{\textit{\scriptsize Schemat podłączenia zewnętrznych interfejsów}}
\end{figure}

\subsection*{Wyświetlacz}
Zgodnie z założeniem, system ma posiadać interfejs  użytkownika. Do tego celu wybrano wyświetlacz HY101CTP z pojemnościowym panelem dotykowym. Przekątna wynosi 10,1",a rozdzielczośś to 1024 na 600 pikseli. Matryca jest sterowana poprzez MIPI-DPI (ang. Mobile Industry Processor Interface - Display Parell Interface). Interfejs składa się z 24 linii reprezentujących kolojno 8-bitowe wartość składowych RGB piksela, linii synchronizacji poziomej HSYNC i pionowej VSYNC, włączenia danych DE oraz sygnału zegarowego PCLK. Ponadto wyświetlacz posiada pin DISP\_ON do włączania podświetlenia oraz BL\_ADJ służącego do sterowania jasnącią poprzez sygnał PWM. Panel dotykowy komunikuje się z mikrokontrolerem poprzez interfejs I2C. Rezystory R3 i R8 mają za zadanie wymusić stan wysoki na liniach, ponieważ są sterownie w trybie otwartego drenu. W tej konfiguracji można tylko zewrzeć linie do masy zmieniając stan wysoki na niski. Pozwoliło to wyeliminować sytuacje w której linia na jednym końcu jest zwarta do masy a na drugim do zasilania co doprowadziło by do zwarcia i gwałtownego wzrostu mocy mogącego uszkodzić układ.
\begin{figure}[!h]
    \centering
    \includegraphics[width=\textwidth]{schematics/display.png}
    \caption{\textit{\scriptsize Schemat podłączenia wyswietlacza}}
\end{figure}

\subsection*{SDRAM}
Do działania interfejsu graficznego potrzebna jest pamięć do przechowywania ramek wysyłanych do wyświetlacza poprzez interfejs MIPI-DPI. Założono iż warstwy będą przechowywane w pamięci w formacie ARGB8888 (po bajcie na każdy kolor i kanał alfa). Kontroler LTDC jest w stanie sprzętowo mieszać dwie warstwy w wynikową która jest wysyłana do wyświetlacza. Zdecydowano, że potrzeba pamięci wystarczająco dużej, by zmieścić trzy bufory. Pierwsza warstwa byłaby przeznaczony na tło, które jest niezmienne podczas działania urządzenia. Dwie pozostałe warstwy służyłby do naprzemiennej prezentacji zmiennych danych takich jak położenie statku powietrznego. Będzie to implementacja mechanizmu podwójnego buforowania pozwalająca wyeliminować migotanie matrycy podczas modyfikacji bufora aktualnie wyświetlanego. Trzy warstwa o rozmiarze 1024 na 600 piskeli w formacie ARGB8888 zajmą 57600 Kb. W pracy zdecydowano się wykorzystać układ IS42S16400J-7TLI posiadający 65536 Kb pamięci. Poniżej przedstawiono schemat połączenia z mikrokontrolerem.

\begin{figure}[!h]
    \centering
    \includegraphics[width=\textwidth]{schematics/sdram.png}
    \caption{\textit{\scriptsize Schemat podłączenia zewnętrzej pamięci SDRAM}}
\end{figure}

\subsection*{Moduł GPS}
Aby system był w stanie popranie obliczyć odległość od namierzonego statu powietrznego i poprawnie zaznaczyć jego pozycję na radarze, potrzebna znać pozycje urządzenia. Do tego zadania wybrano układ NEO-6M-0-001 z zewnętrzną aktywną anteną. Do układu została podłączono zewnętrza bateria podtrzymująca zasilanie. Dzieki temu urządzenie może uruchomić poprzez ciepły start, co pozwala zaoszczędzić czas potrzebny na znalezienie odpowiedniej liczby satelit Do komunikacji z mikrokontrolerem wybrano 
\begin{figure}[!h]
    \centering
    \includegraphics[width=\textwidth]{schematics/gps.png}
    \caption{\textit{ Schemat podłączenia modułu GPS}}
\end{figure}
\newpage

\section{ Wykonanie PCB }
W tym rozdziale szczegółowo opisano projekt oraz wykonanie PCB wtaz z obliczeniami. Opisano decyzję projektowe wynikajcie z ograniczeń technologi oraz występowania niepożądanych zjawisk fizycznych.

\subsection*{Parametry PCB} \label{pcbSection}
W projekcie PCB zdecydowano się na wykonanie technologia czterowarstwową. Pozwoliło to zmniejszyć rozmiary urządzenia oraz zapewnić dobre ekranowanie dla pomiędzy warstwami sygnałowymi. Ograniczyło to przesłuchy pomiędzy warstwami. Ponadto ciągłość warstw referencyjnych (masy i zasilania) pozwala by prądy powrotne przepływało możliwe najkrótszą drogą o najmniejszej impedancji zmniejszając emisje EMC. Poniżej przedstawiono tabele z układem warstw PCB.

\begin{table}[htb]
\def\arraystretch{1.3}% 
\caption{\textit{ Kolejność i grubość warst PCB}}
\label{tab:pcbStack}
\begin{center}
\def\arraystretch{1.3}% 
\begin{tabular}{ |c|c|c|c| }
\hline
Warstwa& grubość [mm] & grubość [mil] \\ 
\hline
sygnały & 0.03556 & 1,4 \\ 
\hline
dielektryk & 0,17018 & 6,7\\ 
\hline
masa & 0,01778 & 0,7\\ 
\hline
rdzeń & 1,1938 & 47\\ 
\hline
zasilanie & 0,01778 & 0,7\\ 
\hline
dielektryk & 0,17018 & 6,7\\ 
\hline
sygnały & 0.03556 & 1,4 \\ 
\hline
\end{tabular}
\end{center}
\end{table}

Warstwy przewodzące wykonane są z miedzi natomiast jako dielektryk wykorzystano materiał FR-408 o stałej dielektrycznej \textbf{$\varepsilon_r$} = 3.66

\subsection*{Dopanowanie impedancji}
Zgodnie z notą katalogową układu NEO-6M-0-001, ścieka antenowa powinna mieć impedancję dopasowaną do Z\textsubscript{0} = 50\textbf{$\Omega$}, którą obliczono z następującego wzoru :
\begin{equation}
Z_0= \frac{87}{\sqrt{\varepsilon_r + 1.41}}\ln{\left(\frac{5.98H}{0.8W + T}\right)} \label{eq:gps_z0}
\end{equation}
dla 
$$
0,1 < W/H < 2,0
$$
$$
1 < \varepsilon_r < 15
$$
gdzie
\begin{itemize}
  \item \textbf{$\varepsilon_r$} - stała dielektryczna
  \item H - grubość dielektryka
  \item W - szerokość ścieżki
  \item T - grubość ścieżki
\end{itemize}
\newpage
\begin{figure}[!h]
    \centering
    \includegraphics[width=\textwidth]{plots/gpsZ0.png}
    \caption{\textit{\scriptsize Impedancja ścieżki w zależności od szerokości ścieżki}}
\end{figure}

Powyższy wykres przedstawia impedancję ścieżki w zależności od szerokości dla anteny modułu GPS obliczoną ze wzoru ~\ref{eq:gps_z0} z parametrami $T = 1,4 mils$ i $H = 6,7 mils$ wziętymi z tabeli ~\ref{tab:pcbStack}. Czerwoną linią zaznaczono pożądane dopasowanie $Z_0 = 50 \Omega$. Założono że W zostanie obliczone z dokładnością do 1 mils. Obliczenia wykonano zaczynając od najmniejszej szerokości gwarantowanej przez producenta $W = 5 mils$, aż do punktu pod prostą z optymalnym dopasowaniem. Najlepsze dopasanie otrzymano dla $W = 12 mils$, gdzie $Z_0 \approx 49.95$
Dla takiego $Z_0$ obliczono współczynnik odbicia, który reprezentuje jaka część sygnału została stracona w wyniku niedopasowania impedancji przy przejściu pomiędzy liniami transmisyjnymi.

\begin{equation}
\Gamma= \frac{Z_l - Z_s}{Z_l + Z_s} \label{eq:gammaGPS}
\end{equation}
gdzie
\begin{itemize}
  \item $Z_l$ - impedancja obciążenia, w tym przypadku impedancja lini transmisyjnej $Z_0 = 49,95 \Omega$
  \item $Z_s$ - impedancja źródła, czyli wejścia antenowego modułu GPS, zgodnie z notą katalogową $Z_s = 50 \Omega$
\end{itemize}

Korzystając ze wzoru ~\ref{eq:gammaGPS} obliczono:
\begin{equation}
\Gamma= \frac{Z_0 - Z_s}{Z_0 + Z_s} = \frac{49,59\Omega -50\Omega}{49,59\Omega  + 50\Omega } \approx 0.0005
\end{equation}

W przeliczeniu na procenty daje to $\Gamma \cdot 100\% = 0.0005 \cdot 100\% = 0.05\%$ sygnału odbitego przez linie transmisyjną. Jest to wartość akceptowalna zatem pozostano prze szerokości $W = 12 mils$.\\

Zgodnie z zaleceniami noty katalogowej wykonano serię przelotek pod i do okola układu GPS (U2). Ten sam zabieg zastosowano również dla ścieżki antenowej (pomiędzy J1 i U2). Zapewniło to lepsze odprowadzanie ciepła przez moduł, a zatem niższą temperaturę pracy i mniejsza emisję EMC. Poniżej zaprezentowano zdjęcie z projektem.
\begin{figure}[!h]
    \centering
    \includegraphics[width=15cm]{pcb/gps.png}
    \caption{\textit{\scriptsize Projekt PCB dla GPS}}
\end{figure}

\subsection{USB}
W projekcie wykorzystano wbudowany w mikrokontroler kontroler interfejsu USB2.0 High-Speed o maksymalnej przepustowości 12Mb/s. Zgodnie ze standardem, należy dopasować impedancję różnicową pomiędzy liniami transmisyjnymi sygnału nieodwróconego i odwróconego do 90 \textbf{$\Omega$}. Poniżej przedstawiono zastosowany wzór oraz obliczenia.
\begin{equation}
Z_0= \frac{174}{\sqrt{\varepsilon_r + 1.41}}\ln{\left(\frac{5.98H}{0.8W + T}\right)} \left(1-0.48e^{(-0.96\frac{D}{H})}\right) \label{eq:usb_zd}
\end{equation}
dla 
$$
0,1 < W/H < 2,0
$$
$$
1 < \varepsilon_r < 15
$$
gdzie
\begin{itemize}
  \item \textbf{$\varepsilon_r$} - stała dielektryczna
  \item H - grubość dielektryka
  \item W - szerokość ścieżki
  \item T - grubość ścieżki
  \item D - odległość pomiędzy ścieżkami
\end{itemize}

\begin{figure}[!h]
    \centering
    \includegraphics[width=\textwidth]{plots/usbzD.png}
    \caption{\textit{\scriptsize Impedancja różnicowa w zależności od szerokości ścieżki}}
\end{figure}

Poniższy wykres przedstawia impedancję różnicową lini transmisyjnych interfejsu USB w zależności od szerokości obliczoną ze wzoru ~\ref{eq:usb_zd} z parametrami $T = 1,4 mils$ i $H = 6,7 mils$ wziętymi z tabeli ~\ref{tab:pcbStack}. Założono odległość pomiędzy ścieżkami $ D = 8mils$ równą rozstawowi padów w mikrokontrolerze. Czerwoną linią zaznaczono pożądane dopasowanie $Z_d = 90 \Omega$. Założono że W zostanie obliczone z dokładnością do 1 mils. Obliczenia wykonano zaczynając od najmniejszej szerokości gwarantowanej przez producenta $W = 5 mils$, aż do punktu pod prostą z optymalnym dopasowaniem. Najlepsze dopasanie otrzymano dla $W = 11 mils$, gdzie $Z_d \approx 89.56$. Zgodnie ze specyfikacją interfejsu USB2.0 Full-speed (12 Mb/s) impedancja różnicowa musi wynosić $Z_d = 90 \pm 15\%$. Zatem $ 76,5\Omega <= Z_d <= 103,5\Omega$. $Z_d$ obliczone dla $W = 11mils$ spełnia to wymaganie.

Wszystkie elementy zostały umieszczone na górnej warstwie sygnałowej, aby nie stosować przelotek które wprowadzając niepożądane pojemności i indukcyjności linii transmisyjnym. Ścieżki są zaginane po kątem nie większym niż 45$^\circ$.Warstwą referencyjną dla sygnałów jest warstwa masy co zapewnia lepsze ekranowanie dla sygnałów szybkich. Linie różnicowe są oddzielone polem masy od innych sygnałów o co najmniej 50mils (1.27mm). Zastosowanie powyższych reguł pozwoliło ograniczyć zjawiska utrudniające dopasowania impedancji. Wspominanie w rozdziale schematu rezystory R5 i R4 służą jako szeregowa terminacja sygnału. Dzięki temu zabiegowi czasy narastania zboczy się większe co zmniejsza generowanie zakłócenia EMC. Układ U6 działa jako zabezpieczenie przeciwko wyładowaniom elektrostatycznym mogącym uszkodzić urządzenie oraz jako dodatkowy filtr EMC.Zgodnie z notą katalogową katalogową układu STM32F767xx ich rezystancja wynosi 22 \textbf{$\Omega$}. Poniżej przedstawiono część projektu PCB z interfejsem USB.

\begin{figure}[!h]
    \centering
    \includegraphics[width=9cm]{pcb/usb.png}
    \caption{\textit{\scriptsize Projekt PCB dla interfejsu USB}}
\end{figure}

\subsection{Interfejsy szybkie}
Częstotliwość sygnału zegarowego FMC wynosi $108Mhz$. W przypadku komunikacji z wyświetlaczem szybkość interfejsu zależy od oczekiwanej liczby klatek na sekundę. Częstotliwość sygnału zegarowego dla interfejsu MIPI-DPI wyraża się wzorem:
\begin{equation}
CLK = W \cdot H \cdot fps \label{eq:fps}
\end{equation}
gdzie:
\begin{itemize}
  \item W - szerokość matrycy w pikselach
  \item H - wysokość matrycy w pikselach
  \item fps - częstotliwość odświeżania ekranu
\end{itemize}
Dla użytego w projekcie wyświetlacza przy założeniu odświeżania matrycy 60Hz korzystając z równania ~\ref{eq:fps} otrzymujemy:
$$
CLK = 1024 \cdot 600 \cdot 60Hz = 614400 \cdot 60Hz = 36864000 Hz \approx 37MHz
$$
Interfejsy o takich częstotliwościach zostały uznane za szybkie, co za tym idzie podjęto dodatkowe działania podczas projektowania ich linii transmisyjnych. Zadbano by warstwy referencyjne pod ścieżkami sygnałowymi były ciągłe, aby zapewnić ekranowanie i ograniczyć przesłuchy od linii po przeciwnej stronie płytki. Ponadto dopasowano długości wszystkich ścieżek w interfejsie, by sygnały przychodziły w tym możliwie podobnym czasie. Wzorując się na projekcie referencyjnym płytki ewaluacyjnej STM32F746G-DISCO zadbano, by różnica długości pomiędzy ścieżkami dla obu interfejsów nie była większa niż $100 mils$.Opóźnienie linii transmisyjnej, czyli czas jaki sygnał potrzebuje na pokonanie określonej drogi wyraża się wzorem:
\begin{equation}
t = \frac{l \sqrt{\varepsilon_r}}{c} \label{eq:td}
\end{equation}
gdzie
\begin{itemize}
  \item l - długość linii transmisyjnej
  \item \textbf{$\varepsilon_r$} - stała dielektryczna 
  \item c - szybkość rozchodzenia się fali w próżni
\end{itemize}
Korzystając ze wzoru ~\ref{eq:td} dla parametrów $l = 0.00254m$ $(100 mils)$ i $c = $ $299$ $792$ $458\frac{m}{s}$ oraz $\varepsilon_r =3,66$ obliczono opóźnienie sygnału czyli maksymalny odstęp czasu w jakim dzieli sygnały w liniach o długości różniącej się o $100mils$.
$$
t = \frac{0.00254m \sqrt{3,66}}{299 792 458\frac{m}{s}} = \frac{0.00485931m}{299 792 458\frac{m}{s}} = 1.621\cdot10^-11 = 16,21 ps
$$

Wyświetlacz jest sterowny bezpośrednio poprzez interfejs LVDS (ang. Low Voltage Differential Signaling), jednak  posiada również wbudowany konwerter THC63LVDM83D pozwalający na komunikację ze pomocą MIPI-DPI. Oznacza to, że wszelkie ograniczenia czasowe powinny być rozpatrywane względem wspomnianego wcześniej układu. Wyjścia
mikrokontrolera zmieniają się przy zboczu opadającym sygnału zegarowego, natomiast są zatrzaskiwane przez konwerter przy zboczu narastającym. Wszystkie sygnały powinny dojść do wyświetlacza od momentu wystąpieniem zbocza opadającego do narastającego z uwzględnieniem czasu ustalenia się sygnału (ang. Setup Time). Jest to najpóźniejszy moment w którym muszą ustalić się stany na wszystkich liniach przed przyjściem sygnału taktującego. Poniżej przedstawiono diagram ilustrujący opisane ograniczenia czasowe.

\begin{figure}[!h]
    \centering
    \includegraphics[width=10cm]{plots/timing.png}
    \caption{\textit{\scriptsize Diagram ograniczeń czasowych}}
\end{figure}

Zatem maksymalna rozbieżność czasowa pomiędzy sygnałami wyraża się wzorem.
\begin{equation}
t_{max} = t_{low}- t_{setup} \label{eq:timing}
\end{equation}
gdzie
\begin{itemize}
  \item \textbf{$t_{low}$} - czas trwania stanu niskiego dla sygnału zegarowego
  \item \textbf{$t_{setup}$} - czas ustalania dla sygnału
\end{itemize}

Z noty katalogowej mikrokontrolera odczytano że stan niski dla sygnał zegarowego LTDC wynosi minimalnie $45\%$
okresu sygnału zegarowego obliczonego z równania ~\ref{eq:fps}zatem:
$$
t_{low} = \frac{1}{36864000Mhz} \cdot 45\% = 27127ps\cdot45\% = 12207ps
$$
W nocie THC63LVDM83D znaleziono $t_{setup} = 2000ps$. Korzystając z ~\ref{eq:timing} obliczono
$$
t_{max} = 4167ps - 2000ps = 2167ps
$$
Ograniczenia czasowe nie zostały przekroczone, ponieważ $t_{max}= 12207ps >= t=16,21$.\\

W przypadku FMC wykorzystywanego do obsługi SDRAM, komunikacja odbywa się w obie strony. Ponownie czas trwania stanu niskiego sygnału zegarowego wynosi $45\%$ okresu. Zatem:
$$
t_{low} = \frac{1}{108Mhz} \cdot 45\% = 9259ps\cdot45\% = 4167ps
$$
 Poniżej przedstawiono tabelę z czasami ustalania dla wszystkich sygnałów interfejsu odczytanych z noty ukłądu IS42S16400J-7TLI.

\begin{table}[htb]
\def\arraystretch{1.3}% 
\caption{\textit{ Czasy ustalania dla wszystkich sygnałów układu SDRAM}}
\label{tab:sdramTiming}
\begin{center}
\begin{tabular}{ |c|c| }
\hline
Parametr  & czas [ps] \\ 
\hline
Input Data Setup Time & 1500 \\ 
\hline
Address Setup Time & 1500\\ 
\hline
CKE Setup Time	 & 1500\\ 
\hline
Command Setup Time	 & 1500\\ 
\hline
\end{tabular}
\end{center}
\end{table}

Oznacza to, że można przyjąć $t_{setup}=1500ps$. Korzystając z równania ~\ref{eq:timing} obliczono:
$$
t_{max} = 4167ps - 1500ps = 2667ps
$$
Ponownie $t_{max}= 2667ps >= t=16,21$, zatem ograniczenia czasowe nie zostały przekroczone.
Poniżej przedstawiono zbliżenie na projekt PCB, gdzie można zauważyć meandry na ścieżkach,których celem jest wyrównanie różnicy długości pomiędzy ścieżkami sygnałowymi.

\begin{figure}[!h]
    \centering
    \includegraphics[width=\textwidth]{pcb/ltdc.png}
    \caption{\textit{\scriptsize Przykład dopasowania długości ścieżek na PCB}}
\end{figure}

\subsection*{Warstwa zasilania}
Większość układów na PCB jest zasilana napięciem 3,3V. Jednak interfejs USB i podświetlenie wyświetlacza wymaga napięciem 5V. Wymagało to odpowiedniego podzielania warstwy trzeciej. Zadbano o to żeby żadne ścieżki sygnałów wrażliwych na zakłócenia nie przechodziły nad przerwą pomiędzy polem zasilanie 3,3V i 5V. Nieciągłość warstwy referencyjne powoduje powstawanie pętli prądowych, ponieważ prąd powrotny szuka innej dostępnej ścieżki powrotu. Zjawisko to może powodować wzrost zakłóceń elektromagnetycznych emitowanych przez urządzenie. Warstwę przedstawia obraz ~\ref{fig:power} w podrozdziale \ref{pcbOverview}.
\subsection{Prezentacja PCB} \label{pcbOverview}
Poniżej przedstawiano obrazy wszystkich warstw z programu wykorzystanego do projektu oraz zdjęcie gotowego PCB.


\begin{center}\centering
\begin{figure}[!h]
    \centering
    \includegraphics[width=\textwidth]{pcb/top.png}
    \caption{\textit{\scriptsize Układ warstwy 1.}}
\end{figure}
\end{center}


\begin{center}\centering
\begin{figure}[!h]
\vskip 2cm
    \centering
    \includegraphics[width=\textwidth]{pcb/gnd.png}
    \caption{\textit{\scriptsize Układ warstwy 2.}}
\end{figure}
\end{center}

\begin{center}\centering
\begin{figure}[!h]
\vskip 2cm
    \centering
    \label{fig:power}
    \includegraphics[width=\textwidth]{pcb/power.png}
    \caption{\textit{\scriptsize Układ warstwy 3.}}
\end{figure}
\end{center}


\begin{center}\centering
\begin{figure}[!h]
\vskip 2cm
    \centering
    \includegraphics[width=\textwidth]{pcb/bottom.png}
    \caption{\textit{\scriptsize Układ warstwy 4.}}
\end{figure}
\end{center}


\begin{center}\centering
\begin{figure}[!h]
\vskip 1cm
    \centering
    \includegraphics[width=\textwidth]{images/bottomPcb.jpg}
    \caption{\textit{\scriptsize Zdjęcie spodu PCB.}}
\end{figure}
\end{center}



\begin{center}\centering
\begin{figure}[!h]
\vskip 1cm
    \centering
    \includegraphics[width=\textwidth]{images/bottomPcb.jpg}
    \caption{\textit{\scriptsize Zdjęcie spodu PCB.}}
\end{figure}
\end{center}

\chapter{ Architektura oprogramowania}

W tym rozdziale opisano strukturę programu wraz z modelem UML oraz opisem funkcjonalności poszczególnych klas. Przedstawiono wykorzystane wzorce projektowe, algorytmy i biblioteki. Opisano poszczególne elementy interfejsu graficznego oraz integrację oprogramowania z warstwą sprzętową.



\section{Wzorzec projektowy MVC}
Model Widok Kontroler (ang. Model View Controler) to wzorzec projektowy wykorzystywany przy tworzeniu aplikacji z interfejsem użytkownika. W MVC można wyróżnić trzy zasadnicze części:
\begin{itemize}
  \item Model - reprezentacja logiki biznesowej (struktura danych oraz wykonywane na nich działania).
  \item Widok - warstwa prezentacji danych zawartych w modelu.
  \item Kontroler - wykonuje operacje na modelu.zapewnia komunikację pomiędzy widokiem i modelem. Obsługuję zadania użytkownika i systemy dotyczące modelu.  
\end{itemize}

Wzorzec MVC zapewnia całkowitą niezależność modelu od widokiem, co ułatwia implementację obu części. Ponadto zapewnia przejrzystość projektu grupując klasy we wcześniej wymienione warstwy abstrakcji. Pozwala to ograniczyć liczbę powiązań pomiędzy komponentami. Poniżej przedstawiono diagram relacji dla wzorca MVC.


\begin{center}\centering
\vspace*{\fill}
\begin{figure}[!h]
    \centering
    \includegraphics[width=\textwidth]{plots/mvc.png}
    \caption{\textit{\scriptsize Relacje pomiędzy komponentami MVC.}}
\end{figure}
\vfill
\end{center}

\section{Model UML}

Poniżej przedstawiono diagram UML reprezentując powiązania i interakcje pomiędzy poszczególnymi klasami.
\vskip 0.55cm
\begin{figure}[!h]
    \centering
    \includegraphics[height=\textwidth, angle=90]{plots/uml.png}
    \caption{\textit{\scriptsize Relacje pomiędzy komponentami MVC.}}
\end{figure}

\noindent
Poniżej opisano funkcjonalności klas we wszystkich przestrzeniach nazw.
\\


\noindent
\textbf{\textit{Application}} - przestrzeń zawierająca klasy najwyższego poziomu odpowiedzialne na działanie aplikacji.
\begin{itemize}[label={}]
  \item \textbf{\textit{FlightRadarApp}} - główna klasa odpowiadająca za działanie i sterowanie aplikacją.
  \item \textbf{\textit{InterruptMenager}} - klasa implementująca wywołania zwrotne dla obsługiwanych przerwań. Zapewnia synchronizacje pomiędzy systemem operacyjnym i procesami a odpowiednimi zdarzeniami sygnalizowanymi przez wywołania zwrotne.
\end{itemize}
\vskip 0.55cm

\noindent
\textbf{\textit{Model}} - przestrzeń która, zawiera klasy związane z realizacją modelu z MVC
\begin{itemize}[label={}]
  \item \textbf{\textit{AircraftRecord}} - klasa do przechowywania informacji o samolotach. Wpisy są zgrupowane w listę. Wezły są wyszukiwane według adresu ICAO. Odpowiada modelowi danyhc z MVC.
  \item \textbf{\textit{FlightControl}} - implementuję logikę modelu, wraz z metodami dostępu i modyfikacji poszczególnych wpisów. Kontroluje czas życia poszczególnych węzłów oraz usuwa przeterminowane. Informuje kontroler o zmianach.
\end{itemize}
\vskip 0.55cm

\noindent
\textbf{\textit{Controler}} - przestrzeń nazw zawierająca klasy związane z realizacją kontrolera z MVC.
\begin{itemize}[label={}]
  \item \textbf{\textit{ADS\_BDecoder}} - klasa odbierająca od obiektu RTLSDR ciągi próbek sygnału radiowego. Odpowiedzialna za wykrywanie ramek od dekodowanie ich do typu ADS\_BMessage.
  \item \textbf{\textit{ADS\_BMessage}} - unia reprezentują odebraną wiadomość. W zależności od parametru downlink format jest interpretowana jako 56 lub 112 bitowa ramka.
  \item \textbf{\textit{FlightControlControler}} - reprezentacja kontrolera w MVC. Klasa jest odpowiedzialna na dodawanie i modyfikowanie wpisów w zależności od odebranych wiadomości. Zajmuje się również przetwarzaniem akcji systemu (przerwania od zegary odliczającego czas życia wpisu) i użytkownika (interakcja z panelem dotykowym). Przekazuje dane z modelu do widoku i informuje o potrzebie odświeżenia interfejsu.
\end{itemize}
\vskip 0.55cm

\noindent
\textbf{\textit{View}} - klasy realizujące funkcjonalność widoku z MVC
\begin{itemize}[label={}]
  \item \textbf{\textit{FlightControlView}} - realizacja widoku w MVC. Klasa jest odpowiedzialna za prezentację danych z modelu oraz przesyłania akcji użytkownika do kontrolera.
\end{itemize}
\vskip 0.55cm

\noindent
\textbf{\textit{Board}} - zawiera klasy będące wysokopoziomowymi interfejsami do obsługi urządzeń wchodzących w skład PCB. JEst odpowiedzialna za inicializację wszystkich klas z przestrzeni BoardSupport i Drivers.
\begin{itemize}[label={}]
  \item \textbf{\textit{BoardMenager}} - klasa zapewniająca komunikację pomiędzy aplikacją a sprzętem.
  \item \textbf{\textit{Led}} - interfejs do obsługi LED znajdującej się na płytce.
  \item \textbf{\textit{RTLSDR}} - klasa 
  \item \textbf{\textit{GPS}} - zajmuję się przetwarzaniem wiadomości przychodzących od modułu GPS poprzez UART. Zapewnia dostęp do zdekodowanych współrzędnych geograficznych.
  \item \textbf{\textit{Display}} - kontroler wyświetlacza realizujący wysokopoziomowe funkcjonalności takie jak menedżer okien i obsługa widżetów.
\end{itemize}
\vskip 0.55cm

\noindent
\textbf{\textit{Drivers}} - przestrzeń nazw zawierająca wszystkie sterowniki. Zaimplementowane zapewniają interfejs do biblioteki HAL odpowiedzialnej za konfigurację i obsługę sprzętu.
\begin{itemize}[label={}]
  \item \textbf{\textit{RCCDriver}} - konfiguracją linii zegarowych oraz pętli PLL (ang. Phase Locked Loop) dla peryferiów oraz rdzenia w mikrokontrolerze. 
  \item \textbf{\textit{GPIODriver}} - konfiguracja pinów dla wszystkich interfejsów wraz z obsługą wyjść i zewnętrznych przerwań.
  \item \textbf{\textit{USBDriver}} - sterownik do obsługi USB2.0 Full-Speed. Odpowiada za wykrywanie podłaczonych urządzeń oraz nawiązywnaia z nimi połączenia.
  \item \textbf{\textit{UARTDriver}} - zapewnia obsługę interfejsu UART (ang.Universal Asynchronous Receiver-Transmitter).
  \item \textbf{\textit{FMCDriver}} - konfiguracja kontrolera zewnętrznej pamięci mikrokontrolera. Wykorzystywany do komunikacji z układem SDRAM.
  \item \textbf{\textit{LTDCDriver}} - obsługa kontrolera wyświetlacza LCD-TFT wraz z konfiguracją wyświetlanych warstw.  
  \item \textbf{\textit{I2CDriver}} - klasa do obsługi interfejsu I2C.
  \item \textbf{\textit{DMADriver}} - sterownik kontrolera DMA (ang Direct Memory Access). Wykorzystywany do przyspieszenia operacji renderowania kolejnych klatek dla wyświetlacza.
\end{itemize}


Komunikacja pomiędzy komponentami odbywa się przy pomocy interfejsów. Każda klasa dziedziczy po swoim interfejsie w którym zadeklarowane są wszystkie metody niezbędne do komunikacji z obiektem. Pozwala to na odseparowanie rzeczywistej implementacji klasy. Dzięki temu dany komponent można łatwo zmieniać bez wpływania na te które z nim oddziałują. Podejście to ułatwia testowanie oprogramowania, ponieważ wewnętrzną logikę można zastąpić spreparowanymi danymi. Za przykład może posłużyć klasa obsługująca sensor, która zawsze zwraca przygotowany wcześniej odczyt. 


\section{Procesy w systemie operacyjnym}
W projekcie wykorzystano system operacyjny FreeRTOS, co pozwoliło podzielić poszczególne części aplikacji na procesy. Wielozadaniowość jest potrzebna by jednocześnie obsługiwać interfejs użytkownika, zarządzać akwizycją danych oraz wykonywać obliczenia związane z logiką programu, tak by użytkownik miał wrażenie płynnego działania aplikacji. Mechanizm semaforów wykorzystano to synchronizacji zadań z przerwaniami sprzętowym, natomiast kolejki wykorzystano do przesyłania pomiędzy nimi. danych i zdarzeń. Ponadto użyto liczników programowych do odliczania czasu życia poszczególnych wpisów w modelu. Ponadto użyto liczników programowych do odliczania czasu życia poszczególnych wpisów w modelu.
\newpage
\noindent
W systemie wydzielono następujące procesy:
\begin{itemize}
\item USBMonitorTask - odpowiedzialny za obsługę maszyny stanów USB oraz wykrywania i konfiguracje Tunera DVB-T jako SDR. 
  
\item RTLSDRDataAquisitionTask - proces zajmujący się obsługą komunikacji z SDR oraz wykrywaniem wiadomości ADS-B i przesyłaniem ich do FlightControlerTask poprzez kolejkę.
    
\item FlightControlerTask - zadanie zajmuje się dekodowaniem wiadomości ADS-B. Przekazuje zdarzenia systemowe, takie jak przepełnienia liczników, oraz zdekodowanie ramki do kontrolera MVC FlightControlControler.

\item GUITask - proces obsługujący interfejs graficzy poprzez klasę FlightControlView.
\end{itemize}
\noindent
Poniżej przedstawiono schematy blokowe poszczególnych zadań.

\begin{figure}[htb]
\centering
\begin{minipage}[c]{0.35\linewidth}
\centering
\includegraphics[width=3.99cm]{plots/modelTask.png}
\caption{Schemat blokowy zadania FlightControlerTask}
\end{minipage}
\hfill
\begin{minipage}[c]{0.55\linewidth}
\centering
\vskip 2.5cm
\includegraphics[width=6.85cm]{plots/dataTask.png}
\vskip 3.55cm
\caption{Schemat blokowy zadania RTLSDRDataAquisitionTask}
\end{minipage}
\end{figure}
\newpage

\begin{figure}[htb]
\centering
\begin{minipage}[c]{0.45\linewidth}
\centering
\includegraphics[width=5cm]{plots/usbTask.png}
\vskip 1.3cm
\caption{Schemat blokowy zadania USBMonitorTask}
\end{minipage}
\hfill
\begin{minipage}[c]{0.45\linewidth}
\centering
\includegraphics[width=6.5cm]{plots/guiTask.png}
\caption{Schemat blokowy zadania GUITask}
\end{minipage}
\end{figure}

\section{Wykrywanie i dekodowanie wiadomości ADS-B}
\subsection*{Wykrywanie Mode-S}
Wiadomości Mode S mają długość 56 lub 112 bitów w zależności od formatu. Przed wysłaniem dane są poddawane modulacji położenia impulsu z częstotliwością sygnału zegarowego 1Mhz. Krótki odstęp pomiędzy stanami wysokimi oznacza logiczne 1 natomiast długi 0. 
Każdy bit jest kodowany co $1\mu$s. Na początku wiadomości dodawana jest preambuła o długości $8\mu$s składająca się z czterech impulsów o długości $0.5\mu$s w odstępach kolejno $0.5\mu$s, $2,5\mu$s, $0,5\mu$s. Tak przygotowany pakiet jest wysyłany na częstotliwości 1090Mhz.


SDR został skonfigurowany, by wydzielać sygnał z fali nośnej o częstotliwość 1090Mhz.
Na jego wyjściu otrzymujemy przebieg o częstotliwości $f=2Mhz$, ponieważ poszczególne impulsy trwają 0,5$\mu$s. Z godnie z twierdzeniem Kotielnikowa-Shannona do poprawnego odtworzenia sygnału potrzebujemy próbkować go z częstotliwością co najmniej $2f$. W SDR próbki są pobierane przez dwa 8 bitowe przetworniki ADC.Przed jednym z układów następuje przesunięcie sygnału w fazie o -90$^\circ$. Dzięki temu dla częstotliwości próbkowania 2Mhz pasmo przenoszenie jest dwukrotnie szersze i również wynosi 2Mhz. Dane otrzymane z SDR są w postaci I/Q. Para próbek I/Q stanowi liczbę rzeczywistą gdzie gdzie I to chwilowa amplituda sygnału a to Q to chwilowa amplituda sygnału przesuniętego w fazie o -90$^\circ$ względem I. Chwilowa amplituda nadanego sygnału to moduł liczby zespolonej I/Q obliczony z następującego wzoru
\\
\begin{equation}
\label{eq:amplitude}
A = \sqrt{I^2 + Q^2}
\end{equation}
\\
Aby wykryć pakiet należy przeliczyć ciąg próbek I/Q na kolejne wartości amplitudy, według wzoru ~\ref{eq:amplitude}. Następnie znaleźć ciąg w sygnale preambułę oraz zdekodować wiadomości przy pomocy demodulacji PPM. Aby potwierdzić poprawność ramki należy obliczyć sumę CRC i porównać z odebraną wartością.
\\

\subsection*{Dekodowanie ADS-B}
ADS-B to wiadomości Mode-S o parametrze Downlink format równym 17. Poniżej przedstawiono strukturę pakietu ADS-B.

\begin{table}[htb]
\def\arraystretch{1.3}% 
\caption{\textit{ Struktura wiadomości ADS-B}}
\label{tab:adsbFrame}
\begin{center}
\begin{tabular}{ |c|c| }
\hline
Rozmiar [bit] & Zawartość\\
\hline
5 & Downlink format\\
\hline
3 & Wersja systemu Mode-S\\
\hline
24 & Adres ICAO\\
\hline
5 & Typ wiadomości\\
\hline
51 & Dane\\
\hline
24 & Suma kontrola CRC\\
\hline
\end{tabular}
\end{center}
\end{table}
\noindent
W zależnosci od typu wiadomość może zawierać następujące informacje.

\begin{table}[htb]
\def\arraystretch{1.3}% 
\caption{\textit{ Struktura wiadomości ADS-B}}
\label{tab:adsbFrame}
\begin{center}
\begin{tabular}{ |c|c| }
\hline
Typ & Zawartość\\
\hline
1 - 4 & Identyfikator samolotu i typ transpondera\\
\hline
5 - 8 & Pozycja naziemna\\
\hline
9 - 18 &  Pozycja powietrzna i wysokość barometryczna\\
\hline
9 & Prędkość\\
\hline
20-22 &  Pozycja powietrzna i wysokość GNSS\\
\hline
23-31 & Zarezerwowane\\
\hline
\end{tabular}
\end{center}
\end{table}

\newpage
Identyfikator samolotu (ang. callsign) jest przechowywany w wiadomości jako ciąg ośmiu 6 bitowych indeksów. Poszczególne znaki są odczytywane z poniższej tablicy 

\begin{table}[htb]
\label{tab:adsb}
  \centering
  \def\arraystretch{1.3}% 
  \begin{tabular}{c}
       \#ABCDEFGHIJKLMNOPQRSTUVWXYZ\#\#\#\#\#\\
\_\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#0123456789\#\#\#\#\#\#
 \end{tabular}
\end{table}

\noindent
gdzie: \# - znak nieużywany, \_ - spacja
\begin{table}[htb]
\def\arraystretch{1.3}% 
\caption{\textit{ Struktura pakietu ADS-B typu 1-4}}
\label{tab:adsbFrame}
\begin{center}
\begin{tabular}{ |c|c|c|c|c|c|c|c| }
\hline
Rozmiar [bit] & 3 & 6 & 6 & 6 & 6 & 6 & 6\\
\hline
Zawartość & \begin{tabular}{c}Rodzaj \\transpondera\end{tabular} & Znak 1 & Znak 2 & Znak 3 & Znak 4 & Znak 5 & Znak 6\\
%Zawartość  
\hline
\end{tabular}
\end{center}
\end{table}

Pozycja statku powietrznego jest zakodowana w formacie CPR (ang. Compact Position Reporting). Wyróżniamy dwie metody dekodowania takich wiadomość. GUP (ang. Globally Unambiguous Position), która potrzebuje do dwóch kolejnych wiadomości i LUP (ang. Locally Unambiguous Position), gdzie wymagana jest pozycja referencyjna, np. lokalizacja odbiornika radiowego, która nie może być odalona od statku powietrznego o więcej niż 180Nm. Ze względu na ograniczone możliwość anteny tunera w projekcie wykorzystano metodę LUP.
Poniżej przedstawiono strukturę pakietu ADS-B dla wiadomości z pozycją.

\begin{table}[htb]
\def\arraystretch{1.3}% 
\caption{\textit{ Zawartość wiadomości ADS-B w zależności od typu}}
\label{tab:adsb}
  \centering
  \def\arraystretch{1.3}% 
  \begin{tabular}{|c|c|c|}
  \hline
  
  \multicolumn{1}{|c|}{Rozmiar [bit]} & \multicolumn{1}{c|}{Nazwa} & \multicolumn{1}{c|}{Zawartość} \\\cline{1-3}
  \multicolumn{1}{|c|}{2} & \multicolumn{1}{c|}{SS} & \multicolumn{1}{c|}{Status lotu}\\\cline{1-3}
  \multicolumn{1}{|c|}{1} & \multicolumn{1}{c|}{NIC$_b$} & \multicolumn{1}{c|}{flaga dokładności pozycji}\\\cline{1-3}
  \multicolumn{1}{|c|}{12} & \multicolumn{1}{c|}{ALT} & \multicolumn{1}{c|}{wysokość barometryczna lub GNSS}\\\cline{1-3}
  \multicolumn{1}{|c|}{1} & \multicolumn{1}{c|}{T} & \multicolumn{1}{c|}{flaga synchronizacji z czasem UTC}\\\cline{1-3}
  \multicolumn{1}{|c|}{1} & \multicolumn{1}{c|}{F} & \multicolumn{1}{c|}{flaga parzystości ramki}\\\cline{1-3}
  \multicolumn{1}{|c|}{17} & \multicolumn{1}{c|}{Lat$_{raw}$} & \multicolumn{1}{c|}{zakodowana szerokość geograficzna w formacie CPR}\\\cline{1-3}
  \multicolumn{1}{|c|}{17} & \multicolumn{1}{c|}{Lon$_{raw}$} & \multicolumn{1}{c|}{zakodowana długość geograficzna w formacie CPR}\\\cline{1-3}   
 \end{tabular}
\end{table}

Pozycja w formacie CPR to dwie wartości zmiennopozycyjne w zakresie od 0 do 1. W wiadomości są zakodowane jako 17 bitowe liczby całkowite w formacie Q1.17. Konwersja z formatu Q1.17 do CPR odbywa się według następującego wzoru.

\begin{equation}
L_{CPR} = \frac{L_{raw}}{2^{17}}
\end{equation}
gdzie:
\begin{itemize}
\item L$_{CPR}$ - zdekodowana długość lub szerokość geograficzna w foramcie CPR.
\item L$_{raw}$ - długość lub szerokość geograficzna zakodowana w formacie Q1.17.
\end{itemize}

\noindent
Poniżej przedstawiono algorytm dekodowania pozycji samolotu.
\\


\noindent
Znaczenie użytych symboli:
\begin{itemize}
\item NZ to ustalona liczba stref szerokość geograficznych wynosząca 15.
\item Lat$_{ref}$ - referencyjna szerokość geograficzna
\item Lon$_{ref}$ - referencyjna długość geograficzna
\item Lat$_{CPR}$ - szerokość geograficzna w formacie CPR
\item Lon$_{CPR}$ - długość geograficzna w formacie CPR
\item Lat - zdekodowano szerokość geograficzna
\item Lon - zdekodowana długość geograficzna
\end{itemize}


\begin{equation}
\renewcommand*{\arraystretch}{1.3}
dLat= \left\{ \begin{array}{ll}

\frac{360}{4NZ} = \frac{360}{60}, & \textrm{F = 0}\\
\frac{360}{4NZ - 1} = \frac{360}{59}, & \textrm{F = 1}\\

\end{array} \right.
\end{equation}
\\
gdzie: F to flaga parzystości wiadomości.
\begin{equation}
mod(x, y) = x - y\floor{\frac{x}{y}}
\end{equation}

\begin{equation}
j = \floor{\frac{Lat_{ref}}{dLat}} + \floor{\frac{mod(Lat_{ref},dLat}{dLat} - Lat_{CPR} + \frac{1}{2}}
\end{equation}

\begin{equation}
Lat = dLat \cdot \left(j + Lat_{CPR}\right)
\end{equation}

\begin{equation}
NF(Lat) = \floor{\frac{2\pi}{\arccos\left(1 - \frac{1 - \cos\left(\frac{2\pi}{2NZ}\right)}{\cos^2\left(\frac{\pi}{180} \cdot Lat\right)}\right)}}
\end{equation}
\\
\begin{equation}
\renewcommand*{\arraystretch}{1.3}
dLon= \left\{ \begin{array}{ll}

\frac{360}{NL(Lat)}, & \textrm{gdy NL(Lat) > 0}\\
360 , & \textrm{gdy NL(Lat) = 0}\\

\end{array} \right.
\end{equation}
\\
\begin{equation}
m = \floor{\frac{Lon_{ref}}{dLon}} + \floor{\frac{mod(Lon_{ref},dLon)}{dLon - Lon_{CPR} + \frac{1}{2}}}
\end{equation}
\\
\begin{equation}
Lon = dLon \cdot \left(m + Lon_{CPR}\right)
\end{equation}

Pułap lotu jest zakodowany na polu ALT w wiadomości ADS-B. Zdekodowanie wymaga usunięcia z liczby 7. bitu (flagi Q),a następnie obliczenia według następującego wzoru:

\begin{equation}
\renewcommand*{\arraystretch}{1.3}
A= \left\{ \begin{array}{ll}

100N - 1000, & \textrm{gdy Q = 0}\\
25N - 1000, & \textrm{gdy Q = 1}\\

\end{array} \right.
\end{equation}
\newpage
\noindent
gdzie: 
\begin{itemize}
\item N - wartość pola ALT uśnięciu bitu Q.
\item A - zdekodowany pułap lotu w stopach.
\end{itemize}

Wiadomości typu 9 dzielimy na dwa rodzaje. Z prędkością względem powierzchni ziemi (Subtype 1) lub powietrzną (Subtype 3). Poniżej przedstawiono format pakietu.

\begin{table}[htb]
\def\arraystretch{1.3}% 
\caption{\textit{ Zawartość wiadomości ADS-B w zależności od typu}}
\label{tab:adsb}
  \centering
  \def\arraystretch{1.3}% 
  \begin{tabular}{|c|c|c|c|c|}
  \hline
  \multicolumn{1}{|c|}{Rozmiar} & \multicolumn{2}{c|}{\multirow{2}{*}{Nazwa}} & \multicolumn{1}{c|}{\multirow{2}{*}{Zawartość (Subtype 1)}}  & \multicolumn{1}{c|}{\multirow{2}{*}{Zawartość (Subtype 3)}}\\
  \multicolumn{1}{|c|}{[bit]} & \multicolumn{2}{c|}{} & \multicolumn{1}{c|}{}& \multicolumn{1}{c|}{}\\\cline{1-5}
  
  \multicolumn{1}{|c|}{1} & \multicolumn{2}{c|}{IC} & \multicolumn{2}{c|}{Flaga zmiany pułapu}\\\cline{1-5}
  \multicolumn{1}{|c|}{1} & \multicolumn{2}{c|}{RES-A} & \multicolumn{2}{c|}{Rejestr zarezerwowany}\\\cline{1-5}
  \multicolumn{1}{|c|}{3} & \multicolumn{2}{c|}{NAC} & \multicolumn{2}{c|}{Niepewność prędkości}\\\cline{1-5}
  \multicolumn{1}{|c|}{1} & \multicolumn{1}{c|}{S$_{EW}$} & \multicolumn{1}{c|}{S$_{Hdg}$} & \multicolumn{1}{c|}{Znak prędkości Wschód-Zachód} & \multicolumn{1}{c|}{Flaga dostępności kursu} \\\cline{1-5}
  \multicolumn{1}{|c|}{10} & \multicolumn{1}{c|}{V$_{EW}$} & \multicolumn{1}{c|}{Hdg} & \multicolumn{1}{c|}{Prędkość Wschód-Zachód}& \multicolumn{1}{c|}{Kurs}\\\cline{1-5}
  \multicolumn{1}{|c|}{1} & \multicolumn{1}{c|}{S$_{NS}$} & \multicolumn{1}{c|}{AS$_t$} & \multicolumn{1}{c|}{Prędkości Północ-Południe} & \multicolumn{1}{c|}{Typ prędkości powietrznej}\\\cline{1-5}
  \multicolumn{1}{|c|}{10} & \multicolumn{1}{c|}{V$_{NS}$} & \multicolumn{1}{c|}{AS}  & \multicolumn{1}{c|}{Prędkość powietrzna}& \multicolumn{1}{c|}{Prędkość powietrzna}\\\cline{1-5}
  \multicolumn{1}{|c|}{1} & \multicolumn{2}{c|}{Vr$_{src}$} & \multicolumn{2}{c|}{Flaga typu wysokości Barometryczna lub GNSS}\\\cline{1-5}
  \multicolumn{1}{|c|}{1} & \multicolumn{2}{c|}{S$_{Vr}$} & \multicolumn{2}{c|}{znak zmiany pułapu}\\\cline{1-5}
  \multicolumn{1}{|c|}{1} & \multicolumn{2}{c|}{Vr} & \multicolumn{2}{c|}{prędkość zmiany pułapu}\\\cline{1-5}
  \multicolumn{1}{|c|}{2} & \multicolumn{2}{c|}{RES-B} & \multicolumn{2}{c|}{rejestr zarezerwowany}\\\cline{1-5}
  \multicolumn{1}{|c|}{1} & \multicolumn{2}{c|}{S$_{Diff}$} & \multicolumn{2}{c|}{znak różnicy wysokości barometrycznej i GNSS}\\\cline{1-5}
  \multicolumn{1}{|c|}{7} & \multicolumn{2}{c|}{Diff} & \multicolumn{2}{c|}{różnica wysokości barometrycznej i GNSS}\\\cline{1-5}
       
 \end{tabular}
\end{table}


Poniżej przedstawiono algorytmy dekodowania kursu i szybkości w zależności od typu wiadomości.
\begin{itemize}
\item v - szybkość statku w węzłach
\item h - kurs statku w stopniach
\end{itemize}

\noindent
Dla wiadomości ADS-B Subtype 1 algorytm wyglada nastepująco:
\begin{equation}
\renewcommand*{\arraystretch}{1.3}
dV_{EW}= \left\{ \begin{array}{ll}
V_{EW} - 1, & \textrm{gdy S$_{EW}$ = 0}\\
-(V_{EW} - 1), & \textrm{gdy S$_{EW}$ = 1}\\
\end{array} \right.
\end{equation}

\begin{equation}
\renewcommand*{\arraystretch}{1.3}
dV_{SN}= \left\{ \begin{array}{ll}
V_{SN} - 1, & \textrm{gdy S$_{SN}$ = 0}\\
-(V_{SN} - 1), & \textrm{gdy S$_{SN}$ = 1}\\
\end{array} \right.
\end{equation}
\\
\noindent
Następnie można wyznaczyć kurs oraz szybkość statku według następujących wzorów.

\begin{equation}
v = \sqrt{dV_{EW}^2 + dV_{SN}^2}
\end{equation}

\begin{equation}
h = arctan2(dV_{EW},dV_{SN}) \cdot \frac{180}{\pi}
\end{equation}


Dla wiadomosći wiadomości ADS-B Subtype 3 algorytm wygląd następująco
\begin{equation}
h = \frac{Hdg}{1024} \cdot 360, \textrm{gdy S$_{Hdg}$ = 1}
\end{equation}

\begin{equation}
v = AS
\end{equation}


\chapter{Interfejs użytkownika}
W tym rozdziale opisano poszczególne elementy interfejsu użytkownika wraz z opisem użytych widżetów i formatem prezentowanych danych.

\chapter{ Podsumowanie }

\addcontentsline{toc}{chapter}{Bibliografia} %utworzenie w spisie treści pozycji Bibliografia
\bibliography{bibliografia} % wstawia bibliografię korzystając z pliku bibliografia.bib - dotyczy BibTeXa, jeżeli nie korzystamy z BibTeXa należy użyć otoczenia thebibliography

%opcjonalnie może się tu pojawić spis rysunków i tabel
% \listoffigures
% \listoftables
\end{document}
